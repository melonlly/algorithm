<html>
    <body>
        <script>
            /*
                239. 滑动窗口最大值
                剑指 Offer 59 - I. 滑动窗口的最大值

                给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
                你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

                返回滑动窗口中的最大值

                输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
                输出: [3,3,5,5,6,7] 
                解释: 

                滑动窗口的位置                最大值
                ---------------               -----
                [1  3  -1] -3  5  3  6  7       3
                 1 [3  -1  -3] 5  3  6  7       3
                 1  3 [-1  -3  5] 3  6  7       5
                 1  3  -1 [-3  5  3] 6  7       5
                 1  3  -1  -3 [5  3  6] 7       6
                 1  3  -1  -3  5 [3  6  7]      7
            */
            /**
             * @param {number[]} nums   原始数组
             * @param {number} k        窗口大小
             * @return {number[]}
             */
            /*
                1.max heap
                    每次挪动，从顶堆中除去窗口最左边元素，右侧加入新元素，加入顶堆中，重新排序，返回堆顶元素
                    时间复杂度：N*logk
                2.双端队列 deque
                    窗口 == 双端队列
                    若新进窗口的元素小于窗口最右侧元素，
                        若此时窗口队列长度不足 k 长度，则将新加入元素加入到窗口最右侧，
                        否则，移除窗口最左侧元素，新元素添加到窗口最右
                    若新进窗口的元素大于窗口最右侧元素，移除最右侧元素，依次类推，保持数组中左侧元素最大
                    时间复杂度: N
            */
            var maxSlidingWindow2 = function (nums, k) {
                nums = nums || [];
                const [window, res] = [[], []]; // 滑动窗口，结果列表
                /* window 中存放的不是具体元素，而是下标 */
                for (let i = 0; i < nums.length; i++) {
                    if (i >= k && window[0] <= i - k) {
                    // if (i >= k && window.length === k) {
                        // 判断队列是否满 window[0] <= i - k
                        // 是否可以用 window.length === k 判断队列是否满了？？？
                        /*
                            规则问题：
                                窗口最大长度为 k
                                若最左侧元素下标已经超出窗口左边界，无论大小，自动要被淘汰
                            若用 window.length === k 判断，只能判断窗口是否满了，
                                根据维护规则，窗口可能是不满的，所以只根据窗口长度判断，可能将已过期元素还保留在窗口内。！！！
                        */
                        window.shift(); // 如果队列满了，需要移除最左元素，为新入元素留出位置
                    }
                    // 维护队列，保持最左元素是最大值
                    // 从右到左（从小到大），依次和新进元素比较，若小于新进元素，则被推出
                    while (
                        window.length &&
                        nums[window[window.length - 1]] <= nums[i]
                    ) {
                        window.pop();
                    }
                    window.push(i);
                    // 首次移动到窗口尾部时，输出一次结果
                    // 之后每移动一次，输出一次结果
                    if (i >= k - 1) {
                        res.push(nums[window[0]]);
                    }
                }
                return res;
            };
            console.log(maxSlidingWindow2([1, 3, 1, 2, 0, 5], 3));

            /*
                动态规划
                
            */
        </script>
    </body>
</html>
