<html>
    <script>
        /*
            给定一个二叉树，找出其最小深度。
            最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
            说明：叶子节点是指没有子节点的节点。
        */
        function TreeNode(val) {
            this.val = val;
            this.left = this.right = null;
        }
        /*
             3          
            / \
           9  20        
             /  \
            15   7
        */
        const root = new TreeNode(3)
        root.left = new TreeNode(9)
        root.right = new TreeNode(20)
        root.right.right = new TreeNode(7)
        root.right.left = new TreeNode(15)

        /*
            分治
        */
        var minDepth0 = function (root) {
            if (!root) return 0
            if (!root.left) return 1 + minDepth0(root.right)
            if (!root.right) return 1 + minDepth0(root.left)
            return 1 + Math.min(minDepth0(root.left), minDepth0(root.right))
        };
        // 见 maximum-depth-of-binary-tree
        var maxDepth0 = function (root) {
            if (!root) return 0
            return 1 + Math.max(maxDepth0(root.left), maxDepth0(root.right))
        };
        console.log(minDepth0(root));
        console.log(maxDepth0(root));

        /**
         * @param {TreeNode} root
         * @return {number}
         */
        /*
            广度优先遍历
                逐层遍历
                    遇到的第一个叶子节点的深度，就是最小深度
                    遇到的最后一个叶子节点的深度，就是最大深度
        */
        var minDepth = function (root) {
            if (!root) return 0
        };
        // 见 maximum-depth-of-binary-tree
        var maxDepth = function (root) {
            if (!root) return 0
        };

        /*
            深度优先遍历
                深度遍历时，记每个节点的level，遇到叶子节点时更新max，min
        */
        var minDepth1 = function (root) {
            if (!root) return 0
        };
        // 见 maximum-depth-of-binary-tree
        var maxDepth1 = function (root) {
            if (!root) return 0
        };

        var DFS = function (node, level = 0, min = 0, max = 0) {
            if (isLeaf(node)) {
                if (min == 0) {
                    min = max = level;
                } else {
                    max = level;
                }
            }
            console.log(node.val, level, min, max);
            
        };
        // 是否叶子节点
        var isLeaf = function (node) {
            return !node.left && !node.right;
        };
        // DFS(root)
    </script>
</html>
