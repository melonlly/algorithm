<html>
    <script>
        /*
            数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。
            每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。
            您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

            输入: cost = [10, 15, 20]
            输出: 15
            解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。

            输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
            输出: 6
            解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
        */
        /**
         * @param {number[]} cost
         * @return {number}
         */
        /*
            动态规划！
        */
        var minCostClimbingStairs = function (cost) {
            let len = cost.length;
            let res = 0;
            let i = -1
            for (; i < len - 3; ) {
                let n = cost[i + 1];
                let nn = cost[i + 2];
                let nnn = cost[i + 3];
                if (nn >= n + nnn) {
                    res += n
                    i += 1
                } else {
                    res += nn
                    i += 2
                }
            }
            if (i == len - 3) res += (Math.min(cost[len - 2], cost[len - 1]))
            return res;
        };
        // console.log(minCostClimbingStairs([0, 1, 1, 1]));
        // console.log(minCostClimbingStairs([1, 2, 2, 0]));
        console.log(minCostClimbingStairs([0, 1, 2, 2]));
        // console.log(minCostClimbingStairs([0, 0, 0, 1]));
        // console.log(minCostClimbingStairs([10, 15, 20]));
        // console.log(
        //     minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])
        // );
    </script>
</html>
