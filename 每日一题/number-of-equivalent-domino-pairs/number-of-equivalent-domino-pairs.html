<html>
    <script>
        /*
            给你一个由一些多米诺骨牌组成的列表 dominoes。

            如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。

            形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。

            在 0 <= i < j < dominoes.length 的前提下，
            找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。

            输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
            输出：1
        */
        /*
            1.暴力求解
                依次遍历，当前元素与右侧所有元素比对，直到 i = dominoes.length - 2
                数组中每个元素都与其他元素比对一次（仅一次）
            2.二元组表示 + 计数
                因为 dominoes[i] 是二元组，可将其转换为 十进制的两位整数
                因为 1 <= dominoes[i][j] <= 9 ，所以 dominoes[i] 最大为99
                每个二元组所表示的整数在 0-100 区间占据一个位置，遍历过程中若存在相同整数，则计数
                计数规则：若有n对构成相同的等价，则计数应该是Cn2（n对中取2对）
        */
        var numEquivDominoPairs = function (dominoes) {
            const num = new Array(100).fill(0);
            let ret = 0;
            for (const domino of dominoes) {
                // 统一格式：小数在前，大数在后
                const val =
                    domino[0] < domino[1]
                        ? domino[0] * 10 + domino[1]
                        : domino[1] * 10 + domino[0];
                ret += num[val];
                num[val]++;
                debugger;
            }
            return ret;
        };
        console.log(
            numEquivDominoPairs([
                [1, 2],
                [2, 1],
                [3, 4],
                [5, 6],
            ])
        );
    </script>
</html>
