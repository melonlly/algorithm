<html>
    <script>
        /*
            原地算法
                原地算法是基本上不需要额外辅助的数据结构,然而,允许少量额外的辅助变量来转换数据的算法
        */
        function reverse_in_place(array) {
            for (let i = 0; i < Math.floor(array / 2); i++) {
                swap(array[i], array[array.length - i]);
            }
        }
    </script>
    <script>
        /*
            给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
            
            输入: [1,2,3,4,5,6,7] 和 k = 3
            输出: [5,6,7,1,2,3,4]
            解释:
                向右旋转 1 步: [7,1,2,3,4,5,6]
                向右旋转 2 步: [6,7,1,2,3,4,5]
                向右旋转 3 步: [5,6,7,1,2,3,4]
            
            输入: [-1,-100,3,99] 和 k = 2
            输出: [3,99,-1,-100]
            解释: 
                向右旋转 1 步: [99,-1,-100,3]
                向右旋转 2 步: [3,99,-1,-100]
            
            ·尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
            ·要求使用空间复杂度为 O(1) 的 原地 算法。
        */
        /*
            从第一位开始，每次移动k个位置
            若当前位置i加上移动位置k大于数组长度，则从第一位再计数
            待移动元素下标 = (i+k)%(len+1)
            直到待移动元素下标归零，则表示数组所有元素都移动完成
        */
        var rotate = function (nums, k) {
            const n = nums.length;
            const newArr = new Array(n);
            for (let i = 0; i < n; ++i) {
                newArr[(i + k) % n] = nums[i];
            }
            for (let i = 0; i < n; ++i) {
                nums[i] = newArr[i];
            }
            return nums
        };
        // console.log(rotate([1, 2, 3, 4, 5, 6, 7], 3));
        // console.log(rotate([-1, -100, 3, 99], 2));

        /*
            数组翻转
                当我们将数组的元素向右移动 kk 次后，尾部 k mod n 个元素会移动至数组头部，其余元素向后移动 k mod n 个位置。
        */
    </script>
</html>
